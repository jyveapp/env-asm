#!/usr/bin/env python3

"""
Devops functions for this package. Includes functions for automated
package deployment, changelog generation, and changelog checking.

This script is generated by the template at
https://github.com/jyveapp/private-python-library-template

Do not change this script! Any fixes or updates to this script should be made
to https://github.com/jyveapp/private-python-library-template
"""
import os
import subprocess
import sys
import tempfile
import time
import traceback

import boto3
import magic
from packaging import version


AWS_ACCESS_KEY_ID_ENV_VAR = 'AWS_ACCESS_KEY_ID'
AWS_SECRET_ACCESS_KEY_ENV_VAR = 'AWS_SECRET_ACCESS_KEY'
CIRCLECI_ENV_VAR = 'CIRCLECI'
GEMFURY_ORG = 'jyve'
DOCUMENTATION_BUCKET = 'jyve-tech-docs'


class Error(Exception):
    """Base exception for this script"""


class NotOnCircleCIError(Error):
    """Thrown when not running on CircleCI"""


class NoAWSCredentialsError(Error):
    """Thrown when no AWS credentials exist"""


class GemfuryPushError(Error):
    """When pushing to gemfury results in an unexpected failure"""


def _check_has_aws_env():
    """Ensures the AWS env vars exist"""
    access_key = os.environ.get(AWS_ACCESS_KEY_ID_ENV_VAR)
    secret_key = os.environ.get(AWS_SECRET_ACCESS_KEY_ENV_VAR)
    if not access_key or not secret_key:  # pragma: no cover
        raise NoAWSCredentialsError(
            f'Must have the "{AWS_ACCESS_KEY_ID_ENV_VAR}" and'
            f' "{AWS_SECRET_ACCESS_KEY_ENV_VAR}" AWS environment variables set'
        )


def _check_git_version():
    """Verify git version"""
    git_version = _shell_stdout("git --version | rev | cut -f 1 -d' ' | rev")
    if version.parse(git_version) < version.parse('2.22.0'):
        raise RuntimeError(
            f'Must have git version >= 2.22.0 (version = {git_version})'
        )


def _shell(
    cmd, check=True, stdin=None, stdout=None, stderr=None
):  # pragma: no cover
    """Runs a subprocess shell with check=True by default"""
    return subprocess.run(
        cmd, shell=True, check=check, stdin=stdin, stdout=stdout, stderr=stderr
    )


def _shell_stdout(cmd, check=True):
    """Runs a shell command and returns stdout"""
    ret = _shell(cmd, stdout=subprocess.PIPE, check=check)
    return ret.stdout.decode('utf-8').strip() if ret.stdout else ''


def _upload_s3_dir(local_dir, bucket, base_s3_dir):
    """Upload a directory to S3

    Contents of local_dir will appear under bucket/base_s3_dir

    Args:
        local_dir (str): The local directory to be uploaded
        bucket (str): The S3 bucket
        base_s3_dir (str): The base S3 directory to which uploads will go
    """
    boto_s3 = boto3.resource('s3')
    mime = magic.Magic(mime=True)

    for root, _, files in os.walk(local_dir):
        for name in files:
            local_p = os.path.join(root, name)
            relative_p = os.path.relpath(local_p, local_dir)
            s3_path = os.path.join(base_s3_dir, relative_p)

            # python-magic doesnt accurately deal with CSS filesg
            if local_p.endswith('.css'):
                content_type = 'text/css'
            else:
                content_type = mime.from_file(local_p)

            obj = boto_s3.Object(bucket, s3_path)
            print(f'uploading {local_p} to {bucket}/{s3_path}...')
            obj.upload_file(local_p, ExtraArgs={'ContentType': content_type})


def _configure_git():
    """Configure git name/email and verify git version"""
    _check_git_version()

    _shell('git config --local user.email "eng@jyve.com"')
    _shell('git config --local user.name "Jyve Devops"')
    _shell('git config push.default current')


def _find_latest_tag():
    return _shell_stdout('git describe --tags --abbrev=0', check=False)


def _find_sem_ver_update():
    """
    Find the semantic version string based on the commit log.
    Defaults to returning "patch"
    """
    sem_ver = 'patch'
    latest_tag = _find_latest_tag()
    log_section = f'{latest_tag}..HEAD' if latest_tag else ''

    cmd = (
        f"git log {log_section} --pretty='%(trailers:key=type,valueonly)'"
        " | grep -q {sem_ver_type}"
    )
    change_types_found = {
        change_type: _shell(
            cmd.format(sem_ver_type=change_type), check=False
        ).returncode
        == 0
        for change_type in ['bug', 'feature', 'api-break']
    }

    if change_types_found['api-break']:
        sem_ver = 'major'
    elif change_types_found['bug'] or change_types_found['feature']:
        sem_ver = 'minor'

    return sem_ver


def _update_package_version():
    """Apply semantic versioning to package based on git commit messages"""
    # Obtain the current version
    old_version = _shell_stdout('make version')
    if old_version == '0.0.0':
        old_version = ''
    latest_tag = _find_latest_tag()

    if old_version and version.parse(old_version) != version.parse(latest_tag):
        raise RuntimeError(
            f'The latest tag "{latest_tag}" and the current version'
            f' "{old_version}" do not match.'
        )

    # Find out the sem-ver tag to apply
    sem_ver = _find_sem_ver_update()
    _shell(f'poetry version {sem_ver}')

    # Get the new version
    new_version = _shell_stdout('make version')

    if new_version == old_version:
        raise RuntimeError(
            f'Version update could not be applied (version = "{old_version}")'
        )

    return old_version, new_version


def _generate_changelog_and_tag(old_version, new_version):
    """Generates a change log using git-tidy and tags repo"""
    # Tag the version temporarily so that changelog generation
    # renders properly
    _shell(f'git tag -f -a {new_version} -m "Version {new_version}"')

    # Generate the full changelog
    _shell('git tidy-log > CHANGELOG.md')

    # Add all updated files
    _shell('git add pyproject.toml CHANGELOG.md')

    # Use [skip ci] to ensure CircleCI doesnt recursively deploy
    _shell(
        'git commit --no-verify -m "Release version'
        f' {new_version} [skip ci]" -m "Type: trivial"'
    )

    # Create release notes just for this release so that we can use them in
    # the commit message
    with tempfile.NamedTemporaryFile() as commit_msg_file:
        _shell(f'echo "{new_version}\n" > {commit_msg_file.name}')
        tidy_log_args = f'^{old_version} HEAD' if old_version else 'HEAD'
        _shell(f'git tidy-log {tidy_log_args} >> {commit_msg_file.name}')

        # Update the tag so that it includes the latest release messages and
        # the automated commit
        _shell(f'git tag -d {new_version}')
        _shell(
            f'git tag -f -a {new_version} -F {commit_msg_file.name}'
            ' --cleanup=whitespace'
        )


def _publish_to_gemfury(dist_type):
    """
    Uses poetry to publish to gemfury

    Gemfury is fickle and can have intermittent 500 gateway errors. Along
    with that, 500 errors can still result in a package being successfully
    uploaded. We treat 409 conflict errors as successes since it means
    the package already exists.

    Note - Since we have no way to remove a previous distribution, this
    publish strategy opens up room for the possibility of tagging a
    package version out of sync with the version on gemfury.
    """
    _shell('poetry build')
    if dist_type == 'standard':
        # Remove wheels when uploading standard distribution
        _shell('rm dist/*.whl')
    elif dist_type == 'wheel':
        # Remove standard distributions when uploading wheel
        _shell('rm dist/*.gz')
    else:
        raise AssertionError(f'Invalid dist_type "{dist_type}"')

    ret = _shell(
        'poetry publish -vvv --repository jyve -n',
        check=False,
        stdout=subprocess.PIPE,
    )
    stdout = ret.stdout.decode('utf-8').strip() if ret.stdout else ''

    # Try again on error. If a 409 conflict was thrown, it means the package
    # was already uploaded
    if ret.returncode and 'Error 409' not in stdout:
        print(f'Error uploading {dist_type} distribution. Trying again')
        time.sleep(30)
        ret = _shell(
            'poetry publish -vvv --repository jyve -n',
            check=False,
            stdout=subprocess.PIPE,
        )
        stdout = ret.stdout.decode('utf-8').strip() if ret.stdout else ''

        if ret.returncode and 'Error 409' not in stdout:
            raise GemfuryPushError(
                f'Could not publish {dist_type} distribution - "{stdout}"'
            )


def _build_and_push_distribution():
    """
    Builds and pushes distribution to Gemfury

    Gemfury is pretty fickle with uploads and occassionally
    returns 500 errors. It also does not handle uploading
    multiple distributions at once very well.

    This method tries to upload one of the distributions at once,
    retrying on failures
    """
    _publish_to_gemfury('standard')
    _publish_to_gemfury('wheel')

    # Push the code changes after succcessful gemfury deploy
    _shell('git push --follow-tags')


def _publish_docs():
    """Make and publish Sphinx docs"""
    _check_has_aws_env()

    print('Building docs...')
    _shell('make docs')

    package_name = _shell_stdout('make project_name')

    print('Uploading docs to s3...')
    _upload_s3_dir(
        'docs/_build/html', DOCUMENTATION_BUCKET, f'{package_name}/latest'
    )


def deploy():
    """Deploys the package and uploads documentation."""
    # Ensure proper environment
    if not os.environ.get(CIRCLECI_ENV_VAR):  # pragma: no cover
        raise NotOnCircleCIError('Must be on CircleCI to run this script')

    _check_has_aws_env()

    _configure_git()

    old_version, new_version = _update_package_version()

    _generate_changelog_and_tag(old_version, new_version)

    _build_and_push_distribution()

    try:
        _publish_docs()
    except Exception:
        msg = (
            f'{traceback.format_exc()}\n\nAn error happened while publishing'
            ' docs and is shown above. Ignoring this error for now since'
            ' documentation publishing is not critical for deploying.'
            ' To publish docs locally, run "publish_docs()" from the primary'
            ' branch in the deploy.py script.'
        )
        print(msg, file=sys.stderr)

    print(f'Deployment complete. Latest version is {new_version}')


if __name__ == '__main__':
    if sys.argv[-1] == 'deploy':
        deploy()
    else:
        raise RuntimeError(f'Invalid subcommand "{sys.argv[-1]}"')
